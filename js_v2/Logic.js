//Формируем логику игры, (тригеры и нужная послед-ность анимаций)function Logic(setting, map){	 this._setting = setting;	 this._map = map;	 this._checker();}//Действия за 1 кадрLogic.prototype.animation = function(){		var that = this;	var setting = this._setting;		//Очищаем карту	var map_height = setting.map.size.y;	var map_width = setting.map.size.x;	setting.context.clearRect(0, 0, map_width, map_height);		//Изменение координат		that._changeCoordinate();	//Отрисовка	that._drow();	}//Создаем гексагон, который движется к ноде. инициализировавшей созданиеLogic.prototype._createHex = function(node){	var that = this;	//Карта	var map = this._map;	//Генераторы	var nodes_gen = this._map.nodes_gen;	//Генератор в котором происходит генерация	var node_gen = map.getNodeById(node.id_gen,'gener');	//Блокируем генератор	node_gen.is_empty = false;			//Хранилище картинок	var image_store = this._setting.image_store;	//Получаем все изображения / типы гексагонов	var image_hex_store = images(image_store).getImagesByType('hex');	//Находим случайный ключ массива типов гексагонов	var random_key = Math.floor(Math.random() * image_hex_store.length);	//Cлучайный тип	var random_type = image_hex_store[random_key];		//Задаем свойства гесагона	var property = {		'img' 	 : random_type.img,		'type' 	 : random_type.name,		'x' 	 : node_gen.pos.drow_point.x,		'y' 	 : node_gen.pos.drow_point.y,		'mid_x'  : node_gen.pos.mid.x,		'mid_y'  : node_gen.pos.mid.y,		'size_x' : this._setting.hex.size.x,		'size_y' : this._setting.hex.size.y	}		//Создаем гексагон	node.hex = new Hex(property);		//Помечаем тип анимаций для данной пары узла/гексагона	node.state_hex = 'move_down_in_gen';}//Изменяем положения//ПроверкиLogic.prototype._checker = function(){	var that 		= this;	var map 		= this._map;	var nodes 		= this._map.nodes;	var nodes_last 	= this._map.nodes_last;		//Проверка на пустоту	//Обходим все ноды справа-на-лево(снизу - вверх)	nodes_last.forEach(function(node_last){				//var node = map.getNodeById(node_last.id, 'usual');			//that._checkerUnstateNode(node);		//if(node_last.state_hex === 'unstate'){			that._checkerUnstateNode(node_last, node_last);		//}	});		//Проверки на n в ряд	that._searchNRowOnMap();		}//Проверяем соседей пустой нодыLogic.prototype._checkerUnstateNode = function(node, check_node){	var that 		= this;	var map 		= this._map;		var neighbor;		if(node.state_hex === 'unstate'){ //Если нода пустая		if(node.neighbors[0] === false && map.getNodeById(check_node.id_gen,'gener').is_empty === true){ //Если свеху нет соседей			map.getNodeById(check_node.id_gen,'gener').is_empty = false;			that._createHex(check_node);			return true;		} else  if(node.neighbors[0] !== false){			neighbor = node.neighbors[0];			if(neighbor.state_hex === 'move_down_in_gen' || neighbor.state_hex === 'move_down'){				check_node.hex = neighbor.hex;				check_node.state_hex = neighbor.state_hex;				neighbor.hex = false;				neighbor.state_hex = 'unstate';				that._checkerUnstateNode(check_node.neighbors[0], check_node.neighbors[0]);							} else if (neighbor.state_hex === 'unstate'){				that._checkerUnstateNode(neighbor, check_node);			} else if (neighbor.state_hex === 'state_in_node'){				check_node.hex = neighbor.hex;				check_node.state_hex = 'move_down';				neighbor.hex = false;				neighbor.state_hex = 'unstate';				that._checkerUnstateNode(check_node.neighbors[0], check_node.neighbors[0]);							} else if(neighbor.neighbors[0] !== false){				that._checkerUnstateNode(neighbor.neighbors[0], neighbor.neighbors[0]);			}		}			} else if(node.neighbors[0] !== false){		neighbor = node.neighbors[0];		that._checkerUnstateNode(neighbor, neighbor);	}}//Взять гексагон соседаLogic.prototype._setNeighborHex = function(node, neighbor){	var that		= this;	var map 		= this._map;	node.hex = neighbor.hex;	node.state_hex = neighbor.state_hex;	neighbor.hex = false;	neighbor.state_hex = 'unstate';	return true;}//Действия или изменения координатLogic.prototype._changeCoordinate = function(){	var that		= this;	var map			= this._map;		//Скорость движения гексагонов	var speed 		= this._setting.hex.speed * this._setting.speed;	//Cкорость исчезания гексагонов	var speed_drop_y = this._setting.hex.speed_drop_y;	var speed_drop_x = this._setting.hex.speed_drop_y;		//Размер гексагона по xy	var hex_size_y  = this._setting.hex.size.y;	var hex_size_x  = this._setting.hex.size.x;		//Все узлы карты	var nodes 		= this._map.nodes;	var is_checker  = false;		nodes.forEach(function(node){				var hex = node.hex;		switch(true){						//Гексагон падает вниз и/или генерируется			case (node.state_hex === 'move_down_in_gen' || node.state_hex === 'move_down'):				var pos_drow_point_y = hex.pos.drow_point.y + speed;							var pos_mid_y		 = hex.pos.mid.y + speed;									//Если гексагон в генераторе				if(node.state_hex === 'move_down_in_gen'){					var node_gen = map.getNodeById(node.id_gen,'gener');					if(node_gen.border < pos_drow_point_y){													console.log(1);												//Изменяем ноду генерации						node_gen.pos.drow_point.y = node_gen.border - hex_size_y *(1 + Math.random() * 2);								node_gen.pos.mid.y = node_gen.pos.drow_point.y + 0.5 * 	hex_size_y;						//Меняем статус ноды						node.state_hex = 'move_down';							node_gen.is_empty = true;													//that._checker(); 						is_checker = true;											}				}								//Если гексагон на карте				if(	pos_drow_point_y >= node.pos.drow_point.y){					hex.pos.drow_point.y = node.pos.drow_point.y;					hex.pos.mid.y 		 = node.pos.mid.y;					node.state_hex = 'state_in_node';											//that._checker(); 					is_checker = true;					} else {					hex.pos.drow_point.y = pos_drow_point_y;					hex.pos.mid.y 		 = pos_mid_y;				}								break;							//Гексагон движется к своей ноде			case (node.state_hex === 'move_to_node'):					if(MyMath.getDistanceBetweenTwoPoints(hex.pos.drow_point.x, hex.pos.drow_point.y, node.pos.drow_point.x, node.pos.drow_point.y)<=speed){					node.hex.pos.drow_point.y = node.pos.drow_point.y;					node.hex.pos.drow_point.x = node.pos.drow_point.x;										hex.pos.mid.x 		 = node.pos.mid.x;					hex.pos.mid.y 		 = node.pos.mid.y;										node.state_hex = 'state_in_node';											//that._checker(); 					is_checker = true;										} else {										var new_pos = MyMath.getPosWhithSpeed(10, hex.pos.drow_point.x, hex.pos.drow_point.y, node.pos.drow_point.x, node.pos.drow_point.y);					hex.pos.drow_point.y = new_pos.y;					hex.pos.drow_point.x = new_pos.x;						hex.pos.mid.x 		 = hex.pos.drow_point.x + hex_size_x/2;					hex.pos.mid.y 		 = hex.pos.drow_point.y + hex_size_y/2;				}				break;										//Гексагон удаляется			case (node.state_hex === 'drop'):					var new_size_x = hex.size.x - speed_drop_x;				var new_size_y = hex.size.y - speed_drop_y;								if(new_size_x <= 0 || new_size_y<= 0){					node.hex = false;					node.state_hex = 'unstate';					//that._checker(); 					is_checker = true;									} else {					hex.size.x = new_size_x;					hex.size.y = new_size_y;										hex.pos.drow_point.y = hex.pos.mid.y - new_size_y/2;					hex.pos.drow_point.x = hex.pos.mid.x - new_size_x/2;				}				break;							}	});	if(is_checker){		that._checker(); 	}	}//Отрисовка всех гексагоновLogic.prototype._drow = function(){	var context		= this._setting.context;	var nodes 		= this._map.nodes;	nodes.forEach(function(node){		var hex = node.hex;		if(node.state_hex !== 'unstate' && node.state_hex !== 'move_to_node'){			context.drawImage(hex.img, hex.pos.drow_point.x, hex.pos.drow_point.y, hex.size.x, hex.size.y);			}	});	nodes.forEach(function(node){		var hex = node.hex;		if(node.state_hex !== 'unstate' && (node.state_hex === 'move_to_node' || node.state_hex === 'change')){			context.drawImage(hex.img, hex.pos.drow_point.x, hex.pos.drow_point.y, hex.size.x, hex.size.y);			}	});}//Найти n рядыLogic.prototype._searchNRowOnMap = function(){	var nodes 		= this._map.nodes;	var map 		= this._map;		//n рядов	var count_n_row = this._setting.count_n_row;		var arr_rows = [];		this.row = [];		//Много логики, так быстрее чем через callback	for(var i = 0; i < nodes.length; i++){		if(nodes[i].state_hex === 'state_in_node' && nodes[i].count_n_row === 0) {			nodes[i].count_n_row = 1;			this._searchNRow(nodes[i]);			for(var j = 0; j < this.row.length; j++){				this.row[j].count_n_row = this.row.length;			}			this.row = [];		}			}		//За третий прогон удаляем n в ряд гексагонов одного типа	nodes.forEach(function(node){		if(node.count_n_row >= count_n_row){			node.state_hex = 'drop';					}			});		nodes.forEach(function(node){		node.count_n_row = 0;			});	}Logic.prototype._searchNRow = function(node){	for(var i = 0; i < node.neighbors.length; i++){		if(node.neighbors[i] !== false){			//Нода соседа				var neighbor = node.neighbors[i];			//Если ноды одинакового типа			if(neighbor.hex.type === node.hex.type && neighbor.state_hex === 'state_in_node' && !in_array(this.row,neighbor)){		 				this.row.push(neighbor);				this._searchNRow(neighbor);			} 		}	}	function in_array(arr, search_value){		var rezult = false;		arr.forEach(function(value){			if(value === search_value){				rezult = true;			}		});		return rezult;	}}	