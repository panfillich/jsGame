//Формируем логику игры, (тригеры и нужная послед-ность анимаций)function Logic(setting, map){	 this._setting = setting;	 this._map = map;	 this._checker();	}//Действия за 1 кадрLogic.prototype.animation = function(){		var setting = this._setting;		//Очищаем карту	var map_height = setting.map.size.y;	var map_width = setting.map.size.x;	setting.context.clearRect(0, 0, map_width, map_height);		//Изменение координат		this._changeCoordinate();	//Отрисовка	this._drow();	}//Создаем гексагон, который движется к ноде. инициализировавшей созданиеLogic.prototype._createHex = function(node){		//Генераторы	var nodes_gen = this._map.nodes_gen;	//Генератор в котором происходит генерация	var node_gen = node.node_gen;	//Блокируем генератор	node_gen.is_empty = false;			//Хранилище картинок	var image_store = this._setting.image_store;	//Получаем все изображения / типы гексагонов	var image_hex_store = images(image_store).getImagesByType('hex');	//Находим случайный ключ массива типов гексагонов	var random_key = Math.floor(Math.random() * image_hex_store.length);	//Cлучайный тип	var random_type = image_hex_store[random_key];		//Задаем свойства гесагона	var property = {		'img' 	 : random_type.img,		'type' 	 : random_type.name,		'x' 	 : node_gen.pos.drow_point.x,		'y' 	 : node_gen.pos.drow_point.y,		'mid_x'  : node_gen.pos.mid.x,		'mid_y'  : node_gen.pos.mid.y,		'size_x' : this._setting.hex.size.x,		'size_y' : this._setting.hex.size.y	}		//Создаем гексагон	node.hex = new Hex(property);		//Помечаем тип анимаций для данной пары узла/гексагона	node.state_hex = 'move_down_in_gen';}//Изменяем положения//ПроверкиLogic.prototype._checker = function(){	//Последний ноды в каждом столбце	var nodes_last 	= this._map.nodes_last;		//Проверка на пустоту	//Обходим все ноды справа-на-лево(снизу - вверх)	nodes_last.forEach(function(node_last){				this._checkerUnstateNode(node_last, node_last);	}.bind(this));		//Проверки на n в ряд	this._searchNRowOnMap();	}//Проверяем соседей пустой нодыLogic.prototype._checkerUnstateNode = function(node, check_node){	var neighbor; //узел соседа		if(node.state_hex === 'unstate'){ //Если нода пустая		//Если сверху нет соседей и генератор свободен		if(node.neighbors[0] === false && check_node.node_gen.is_empty === true){ 			check_node.node_gen.is_empty = false;			this._createHex(check_node);			return true;		} else  if(node.neighbors[0] !== false){ //Если нода имеет гексагон						neighbor = node.neighbors[0];					if(neighbor.state_hex === 'move_down_in_gen' || neighbor.state_hex === 'move_down'){				check_node.hex = neighbor.hex;				check_node.state_hex = neighbor.state_hex;				neighbor.hex = false;				neighbor.state_hex = 'unstate';				this._checkerUnstateNode(check_node.neighbors[0], check_node.neighbors[0]);							} else if (neighbor.state_hex === 'unstate'){				this._checkerUnstateNode(neighbor, check_node);			} else if (neighbor.state_hex === 'state_in_node'){				check_node.hex = neighbor.hex;				check_node.state_hex = 'move_down';				neighbor.hex = false;				neighbor.state_hex = 'unstate';				this._checkerUnstateNode(check_node.neighbors[0], check_node.neighbors[0]);							} else if(neighbor.neighbors[0] !== false){				this._checkerUnstateNode(neighbor.neighbors[0], neighbor.neighbors[0]);			}		}			} else if(node.neighbors[0] !== false){		neighbor = node.neighbors[0];		this._checkerUnstateNode(neighbor, neighbor);	}}//Действия или изменения координатLogic.prototype._changeCoordinate = function(){	//Скорость движения гексагонов	var speed_move_down 		= this._setting.hex.speed_move_down * this._setting.speed;	//Cкорость исчезания гексагонов	var speed_drop_y = this._setting.hex.speed_drop_y * this._setting.speed;	var speed_drop_x = this._setting.hex.speed_drop_y * this._setting.speed;	//Скорость движения к родительской ноде (обмен и/или возврат)	var speed_move_to_node = this._setting.hex.speed_move_to_node * this._setting.speed;		//Все узлы карты	var nodes 		= this._map.nodes;	var is_checker  = false;		nodes.forEach(function(node){				var hex = node.hex;		switch(true){			//Для ускорения проверка на пустую ноду			case(node.state_hex === 'state_in_node'):				break;							//Гексагон падает вниз и/или генерируется			case (node.state_hex === 'move_down_in_gen' || node.state_hex === 'move_down'):				var pos_drow_point_y = hex.pos.drow_point.y + speed_move_down;								//Если гексагон в генераторе				if(node.state_hex === 'move_down_in_gen'){					var node_gen = node.node_gen;					if(node_gen.border < pos_drow_point_y){						//Изменяем ноду генерации						node_gen.newRandPosY();						//node_gen.pos.drow_point.y = node_gen.border - hex_size_y *(1 + Math.random() * 2);								//node_gen.pos.mid.y 		  = node_gen.pos.drow_point.y + 0.5 * 	hex_size_y;						//Меняем статус ноды						node.state_hex 		= 'move_down';						//Меняем статус ноды-генератора: генератор свободен						node_gen.is_empty 	= true;							//Запускать проверку после перебоа всех узлов?						is_checker 			= true;											}				}								//Если гексагон на карте				if(	pos_drow_point_y >= node.pos.drow_point.y){					hex.setDrowPos(node.pos.drow_point.x, node.pos.drow_point.y);					node.state_hex 		 = 'state_in_node';						is_checker 			 = true;					} else {					hex.setDrowPos(hex.pos.drow_point.x, pos_drow_point_y);				}								break;							//Гексагон движется к своей ноде			case (node.state_hex === 'move_to_node'):					if(MyMath.getDistanceBetweenTwoPoints(hex.pos.mid.x, hex.pos.mid.y, node.pos.mid.x, node.pos.mid.y)<=speed_move_to_node){					hex.setMidPos(node.pos.mid.x,node.pos.mid.y);									node.state_hex 			  = 'state_in_node';						is_checker 				  = true;										} else {										var new_pos = MyMath.getPosWhithSpeed(speed_move_to_node, hex.pos.mid.x, hex.pos.mid.y, node.pos.mid.x, node.pos.mid.y);					hex.setMidPos(new_pos.x,new_pos.y);				}				break;										//Гексагон удаляется			case (node.state_hex === 'drop'):					var new_size_x = hex.size.x - speed_drop_x;				var new_size_y = hex.size.y - speed_drop_y;								if(new_size_x <= 0 || new_size_y<= 0){					node.hex = false;					node.state_hex = 'unstate';					is_checker = true;									} else {					hex.setNewSize(new_size_x, new_size_y);				}				break;							}	});		//Проверки n в ряд и наличие пустых клеток	if(is_checker){		this._checker(); 	}	}//Отрисовка всех гексагоновLogic.prototype._drow = function(){	var context		= this._setting.context;	var nodes 		= this._map.nodes;	var hex;	//1 слой	nodes.forEach(function(node){		if(node.state_hex !== 'unstate' && !(node.state_hex === 'move_to_node' || node.state_hex === 'change')){			hex = node.hex;			context.drawImage(hex.img, hex.pos.drow_point.x, hex.pos.drow_point.y, hex.size.x, hex.size.y);			}	});	//2 слой	nodes.forEach(function(node){		if(node.state_hex !== 'unstate' && (node.state_hex === 'move_to_node' || node.state_hex === 'change')){			hex = node.hex;			context.drawImage(hex.img, hex.pos.drow_point.x, hex.pos.drow_point.y, hex.size.x, hex.size.y);			}	});}//Найти n рядыLogic.prototype._searchNRowOnMap = function(){	var nodes 		= this._map.nodes;	//n рядов	var count_n_row = this._setting.count_n_row;		var arr_rows = [];		this.row = [];		//Много логики, так быстрее чем через callback	for(var i = 0; i < nodes.length; i++){		if(nodes[i].state_hex === 'state_in_node' && nodes[i].count_n_row === 0) {			nodes[i].count_n_row = 1;			this._searchNRow(nodes[i]);			for(var j = 0; j < this.row.length; j++){				this.row[j].count_n_row = this.row.length;			}			this.row = [];		}			}		//За третий прогон удаляем n в ряд гексагонов одного типа	nodes.forEach(function(node){		if(node.count_n_row >= count_n_row){			node.state_hex = 'drop';					}			});		nodes.forEach(function(node){		node.count_n_row = 0;			});	}Logic.prototype._searchNRow = function(node){	for(var i = 0; i < node.neighbors.length; i++){		if(node.neighbors[i] !== false){			//Нода соседа				var neighbor = node.neighbors[i];			//Если ноды одинакового типа			if(neighbor.hex.type === node.hex.type && neighbor.state_hex === 'state_in_node' && !in_array(this.row,neighbor)){		 				this.row.push(neighbor);				this._searchNRow(neighbor);			} 		}	}	function in_array(arr, search_value){		var rezult = false;		arr.forEach(function(value){			if(value === search_value){				rezult = true;			}		});		return rezult;	}}	