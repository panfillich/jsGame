//Формируем карту (По сути находим координаты позиций гексагонов)//И создаем логику игры (По сути создаем события) function CreateMapLogic(setting){	CreateMap(setting);}//Формируем карту //тут мы задаем форму карты, //я задам 2 формы 8 - угольная и квадратная//по аналогии можно создать какую угодноfunction CreateMap(setting){	//Размер гексагона	var hex_size_x = setting.hex.size.x;	var hex_size_y = setting.hex.size.y;		//Максимально-возможное кол-во гексагонов по осям	var hex_count_x = setting.hex.count.x;	var hex_count_y = setting.hex.count.y;		//Размеры карты	var map_size_x = setting.map.size.x;	var map_size_y = setting.map.size.y;			//При дальнейшей рабтоте с картой необходимо:	var map = setting.map.store;	//Массив координа всех позиций гексагонов		map.hex = new Array;			//массив id самых нижних позиций y для каждого x		map.hex_last = new Array;			//массив координат позиций, с которых происходит генерация 		//и их статусы (генерирует / свободен)		map.hex_gen = new Array;		//map.hex_gen.border{y}  - 	граница, после при прохождения которой гексагон сигнализирует, 		//							что можно генерировать следующий гексагон 		//							<= 0 т.к. генерация происходит за пределами canvas		map.hex_gen.border = 0;			//Формируем прямоугольную карту	//Формирование начинаем снизу вверх с центра	//Начинаем работать от  x = 0	//Заполняем снизу - вверх, затем смещаемся на след. столбец	var x,y; 					//Позиции В ГЕКСАГОНАХ!	var pos_x, pos_y;			//Позиции верхнего правого угла	var pos_mid_x, pos_mid_y;	//Позиции центра	var	id = 1; 				//Id узла	var id_gen = 1;				//ID узла-генератора			//Находим координаты узлов (центров гексагонов + точек для рисования оных)	for(x = 0; x <  hex_count_x; x++){		//массив координат самых нижних позиций y для каждого x				if(x%2){ 			y = hex_count_y-2;						//Добавляем узел генерации конкретного столбца			map.hex_gen.push(new GenNode(id_gen,(3/4)*x*hex_size_x,-(3/2)*hex_size_y,(3/4)*x*hex_size_x + hex_size_x/2,-hex_size_y));			id_gen++;		} else { 			y = hex_count_y-1;				map.hex_gen.push(new GenNode(id_gen,(3/4)*x*hex_size_x,-hex_size_y, (3/4)*x*hex_size_x + hex_size_x/2, -hex_size_y/2));			id_gen++		}					//Добавляем ID последнего узла и кол-во гексагонов сверху		map.hex_last.push({'id' : id, 'count_hex' : y});				do{ addNode(); id++; y--;} while (y >= 0);	}			//Добавляем узел на карту	//Работаем через замыкания	function addNode(){			//Позиции верхнего правого угла		pos_x = x * 3*(hex_size_x/4);		pos_y = y * hex_size_y;		if(x%2){			pos_y += hex_size_y/2;		}					//Позиции центра		pos_mid_x = pos_x + hex_size_x/2;		pos_mid_y = pos_y + hex_size_y/2;				//Добавляем точку		map.hex.push(			new MapNode(				id, pos_x, pos_y, pos_mid_x, pos_mid_y, id_gen			)		);	}		//Находим соседей		setIdNeighbor(map.hex, hex_size_x, hex_size_y);		//Сохраняем карту	setting.map.store = map;}//Установить соседей узлов//nodes 		- массив узлов//hex_size_x 	- ширина гексагона//hex_size_y	- высота гексагонаfunction setIdNeighborы(nodes, hex_size_x, hex_size_y){ 	//Обход по часовой стрелке с 00:00	//(top) -> (right-top) -> (right-down) -> (down) -> (left-down) -> (left-top)			nodes.forEach(function(node, i, nodes){		var node_mid_x = node.pos.mid.x;		var node_mid_y = node.pos.mid.y;				var neighbors = new Array;		neighbors.push(			{//top				'mid_x' : node_mid_x,				'mid_y' : node_mid_y - hex_size_y			},			{//right-top				'mid_x' : node_mid_x + 3*hex_size_x/4, 				'mid_y' : node_mid_y - hex_size_y/2			},			{//right-down				'mid_x' : node_mid_x + 3*hex_size_x/4, 				'mid_y' : node_mid_y + hex_size_y/2							},			{//down				'mid_x' : node_mid_x,				'mid_y' : node_mid_y + hex_size_y							},			{//left-down				'mid_x' : node_mid_x - 3*hex_size_x/4, 				'mid_y' : node_mid_y + hex_size_y/2								},			{//left-top				'mid_x' : node_mid_x - 3*hex_size_x/4, 				'mid_y' : node_mid_y - hex_size_y/2								}		);		neighbors.forEach(function(neighbor, i){			node.neighbors[i]  = searchNeighbor(nodes, hex_size_x, hex_size_y, neighbor.mid_x, neighbor.mid_y);		});	});}//Найти соседа по координатам центра соседа//nodes 		- массив узлов//hex_size_x 	- ширина гексагона//hex_size_y	- высота гексагона//mid_x			- примерная координа центра x соседа//mid_y			- примерная координа центра y соседаfunction searchNeighbor(nodes, hex_size_x, hex_size_y, mid_x, mid_y){	var id = 0;		//Определяем границы	var border_x_max = mid_x + hex_size_x/2; 	var border_x_min = mid_x - hex_size_x/2; 	var border_y_max = mid_y + hex_size_y/2; 	var border_y_min = mid_y - hex_size_y/2; 		//Находим ID соседа	nodes.forEach(function(node, i, nodes){		if(	   node.pos.mid.x < border_x_max && node.pos.mid.x > border_x_min && node.pos.mid.y < border_y_max 	&& node.pos.mid.y > border_y_min){							id = node.id;				}			});		return id;}//Узел function Node(id, x, y, mid_x, mid_y){	//id узла	this.id = id;		//Позиция узла при рисовании и его центр	this.pos = {		'drow_point' : {			'x' : x,			'y' : y		},		'mid' : {			'x' : mid_x,			'y' : mid_y,		}	}}//Обычный узел на картеfunction MapNode(id, x, y, mid_x, mid_y, id_gen){	Node.apply(this, arguments);			//id генератора для данного узла	this.id_gen = id_gen;		//Соседние гексагоны	//Обход по часовой стрелке с 00:00	//(top) -> (right-top) -> (right-down) -> (top) -> (left-down) -> (left-down)	this.neighbors = new Array;		//Связан ли с гексагоном	this.is_hex = false;		//Гексагон, связанный с этой точкой	this.hex = {};		//Тут логика, изменение координат гексагонов и статусов	this.animation = new Function;}//Узел - генератор//Обычный узел на картеfunction GenNode(id, x, y, mid_x, mid_y){	Node.apply(this, arguments);	//Cвободен ли узел	this.is_empry = true;}